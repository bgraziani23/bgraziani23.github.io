<head>
    <title>CoolSplish</title>

    <link rel="stylesheet" href="style.css">

    <!-- Barlow Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Aldrich&family=Barlow+Condensed:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            background: #1c1c1c;
            overflow-y: hidden;
            overflow-x: hidden;
        }

        /* Centers only the table */
        .table-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: calc(100vh - 200px);
        }

        .barlow-condensed-regular {
            font-family: "Barlow Condensed", sans-serif;
            font-weight: 400;
            font-style: normal;
        }

        table {
            border-collapse: collapse;
            outline: 20px solid #ebebeb; /* grows outward only */
            border-radius: 0px;
            text-shadow: 0 0 6px rgba(235, 235, 235, 0.75);
            outline-offset: 0;

            box-shadow: 0 0 55px rgba(235, 235, 235, 0.75);
        }

        td {
            width: 60px;
            height: 60px;
            user-select: none;
            box-sizing: border-box;
            color: #ebebeb;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            text-align: center;
            font-family: "Barlow Condensed", sans-serif;
            font-weight: 400;
            font-style: normal;
            font-size: 20px;
        }

        tr:last-child td:last-child {
            background: #ebebeb;
            /* outline: 2px solid #1c1c1c;
            outline-offset: -2px; */
        }

        .piece {
            position: absolute;
            cursor: grab;
        }

        .piece-cell {
            width: 60px;
            height: 60px;
            background: #ebebeb;
            position: absolute;
        }

        #timer {
            position: fixed;
            top: 120px;
            right: 30px;
            color: #ebebeb;
            font-size: 28px;
            letter-spacing: 1px;
            text-shadow: 0 0 8px rgba(235, 235, 235, 0.6);
            z-index: 100;
            user-select: none;
        }

    </style>
</head>
<body>

  <!-- Nav Bar -->
  <nav>
    <div></div>
    <div class="nav-name">Calendar Puzzle</div>
    <div class="nav-links">
      <a href="index.html">Home</a>
      <a href="about.html">About</a>
      <a href="projects.html">Projects</a>
      <a href="contact.html">Contact</a>
    </div>
</nav>
  <!-- Nav Bar -->

<div id="timer" class="barlow-condensed-regular">0:00</div>

<div class="table-wrapper">
    <table id="grid">
        <tbody>
            <!-- 9 rows, 6 columns -->
            <tr>
                <td>JAN</td> <td>FEB</td> <td>MAR</td> <td>APR</td> <td>1</td> <td>2</td> <td>3</td> <td>MON</td> <td>TUE</td>
            </tr>
            <tr>
                <td>MAY</td> <td>4</td> <td>5</td> <td>6</td> <td>7</td> <td>8</td> <td>9</td> <td>WED</td><td></td>
            </tr>
            <tr>
                <td>JUN</td> <td>10</td> <td>11</td> <td>12</td> <td>13</td> <td>31</td> <td>15</td> <td>THU</td><td></td>
            </tr>
            <tr>
                <td>JUL</td> <td>16</td> <td>17</td> <td>18</td> <td>19</td> <td>20</td> <td>21</td> <td>FRI</td> <td>SAT</td>
            </tr>
            <tr>
                <td>AUG</td> <td>22</td> <td>23</td> <td>24</td> <td>25</td> <td>26</td> <td>27</td> <td></td> <td>SUN</td>
            </tr>
            <tr>
                <td>SEP</td> <td>OCT</td> <td>NOV</td> <td>DEC</td> <td>28</td> <td>29</td> <td>30</td> <td>14</td><td></td>
            </tr>
        </tbody>
    </table>
</div>

  <script>
    const CELL_SIZE = 60;
    const ROWS = 6;
    const COLS = 9;

    const answerGrid = [
        ["JAN", "FEB", "MAR", "APR", 1, 2, 3, "MON", "TUE"],
        ["MAY", 4, 5, 6, 7, 8, 9, "WED", "BLANK"],
        ["JUN", 10, 11, 12, 13, 31, 15, "THU", "BLANK"],
        ["JUL", 16, 17, 18, 19, 20, 21, "FRI", "SAT"],
        ["AUG", 22, 23, 24, 25, 26, 27, "BLANK", "SUN"],
        ["SEP", "OCT", "NOV", "DEC", 28, 29, 30, 14, "BLOCKED"]
    ]

    // DATE
    const currentDate = new Date();

    const dayOfWeekNumber = currentDate.getDay();
    const days = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];
    const dayOfWeekName = days[dayOfWeekNumber];

    const monthNumber = currentDate.getMonth();
    const months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
    const monthName = months[monthNumber];

    const dateOfMonth = currentDate.getDate();

    const answers = [dayOfWeekName, monthName, dateOfMonth];
    // const answers = ["JUN", "NOV", "TUE"];

    const controller = new AbortController();
    const signal = controller.signal;

    const startTime = performance.now();
    let winShown = false;

    const timerEl = document.getElementById("timer");
    function updateTimer() {
        if (winShown) return;

        const elapsedMs = performance.now() - startTime;
        const totalSeconds = Math.floor(elapsedMs / 1000);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;

        timerEl.textContent =
            `${minutes}:${seconds.toString().padStart(2, "0")}`;

        requestAnimationFrame(updateTimer);
    }

    updateTimer();

    /*
    Grid state:
    null = empty
    string = piece id occupying that cell
    */
    const gridState = Array.from({ length: ROWS }, () =>
        Array(COLS).fill(null)
    );

    // Block bottom-right cell
    const blockedCells = new Set(["5,8"]); // row,col

    const SHAPES = {
        LINE: [
            [0, 0],
            [0, 1],
            [0, 2],
            [0, 3],
            [0, 4]
        ],

        T: [
            [0, 0],
            [0, 1],
            [0, 2],
            [1, 1],
            [2, 1]
        ],

        BATON: [
            [0, 0],
            [0, 1],
            [0, 2],
            [0, 3],
            [1, 1]
        ],

        TALLZ: [
            [0, 0],
            [0, 1],
            [0, 2],
            [-1, 2],
            [-1, 3]
        ],

        TALLL: [
            [0, 0],
            [0, 1],
            [1, 1],
            [2, 1],
            [3, 1]
        ],

        U: [
            [0, 0],
            [0, 2],
            [1, 0],
            [1, 1],
            [1, 2]
        ],

        L: [
            [0, 0],
            [0, 1],
            [0, 2],
            [1, 0],
            [2, 0]
        ],

        Z: [
            [0, 0],
            [-1, 0],
            [-1, 1],
            [-1, 2],
            [-2, 2]
        ],

        BLOCKUS: [
            [0, 0],
            [0, 1],
            [-1, 1],
            [-1, 2],
            [-2, 1]
        ],

        THUMB: [
            [0, 0],
            [0, 1],
            [0, 2],
            [-1, 1],
            [-1, 2]
        ]
    };


    class Piece {
        constructor(id, shape, startX, startY, flipped = false) {
            this.id = id;
            this.shape = shape;
            this.el = document.createElement("div");
            this.el.className = "piece";
            this.el.dataset.id = id;
            this.flipped = flipped
            this.color = this.flipped ? "#ffcccc" : "#ebebeb";;
            
            this.el.pieceRef = this;

            // Create visual cells
            shape.forEach(([r, c]) => {
                const cell = document.createElement("div");
                cell.className = "piece-cell";
                cell.style.left = `${c * CELL_SIZE}px`;
                cell.style.top = `${r * CELL_SIZE}px`;
                cell.style.background = this.color;

                cell.dataset.r = r;
                cell.dataset.c = c;

                this.el.appendChild(cell);
            });

            this.el.style.left = `${startX}px`;
            this.el.style.top = `${startY}px`;

            document.body.appendChild(this.el);
            this.makeDraggable();
            this.addOutline();
        }

        getCells(row, col) {
            return this.shape.map(([r, c]) => [row + r, col + c]);
        }

        makeDraggable() {
            let offsetX, offsetY, dragging = false;

            this.el.addEventListener("mousedown", e => {
                dragging = true;
                offsetX = e.clientX - this.el.offsetLeft;
                offsetY = e.clientY - this.el.offsetTop;
                this.el.style.cursor = "grabbing";

                clearPieceFromGrid(this);
            }, { signal });

            document.addEventListener("mousemove", e => {
                if (!dragging) return;
                this.el.style.left = `${e.clientX - offsetX}px`;
                this.el.style.top = `${e.clientY - offsetY}px`;
            }, { signal });

            document.addEventListener("mouseup", () => {
                if (!dragging) return;
                dragging = false;
                this.el.style.cursor = "grab";
                trySnap(this);
            }, { signal });
        }

        addOutline() {
            const STROKE = 1;
            // const INSET = STROKE / 2;
            const INSET = 0;

            // const edges = new Set();
            const edges = new Map();

            // For each cell, add its 4 edges
            this.shape.forEach(([r, c]) => {
                const x = c * CELL_SIZE;
                const y = r * CELL_SIZE;

                const cellEdges = [
                    { x1: x, y1: y, x2: x + CELL_SIZE, y2: y,     nx: 0, ny: 1 },  // top (inward is +Y)
                    { x1: x + CELL_SIZE, y1: y, x2: x + CELL_SIZE, y2: y + CELL_SIZE, nx: -1, ny: 0 }, // right (inward is -X)
                    { x1: x + CELL_SIZE, y1: y + CELL_SIZE, x2: x, y2: y + CELL_SIZE, nx: 0, ny: -1 }, // bottom (inward is -Y)
                    { x1: x, y1: y + CELL_SIZE, x2: x, y2: y,     nx: 1, ny: 0 }   // left (inward is +X)
                ];

                const key = e => `${e.x1},${e.y1},${e.x2},${e.y2}`;
                const reverseKey = e => `${e.x2},${e.y2},${e.x1},${e.y1}`;
                cellEdges.forEach(edge => {
                    const rev = reverseKey(edge);
                    if (edges.has(rev)) {
                        edges.delete(rev);
                    } else {
                        edges.set(key(edge), edge);
                    }
                });
            });

            // Build SVG
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.style.position = "absolute";
            svg.style.left = "0";
            svg.style.top = "0";
            svg.style.overflow = "visible";
            svg.style.pointerEvents = "none";

            edges.forEach(edge => {
                const { x1, y1, x2, y2, nx, ny } = edge;

                const line = document.createElementNS(svg.namespaceURI, "line");
                line.setAttribute("x1", x1 + nx * INSET);
                line.setAttribute("y1", y1 + ny * INSET);
                line.setAttribute("x2", x2 + nx * INSET);
                line.setAttribute("y2", y2 + ny * INSET);

                line.setAttribute("stroke", "#1c1c1c");
                line.setAttribute("stroke-width", STROKE);
                line.setAttribute("stroke-linejoin", "round");

                svg.appendChild(line);
            });

            this.el.appendChild(svg);
        }
    }


    function canPlace(piece, row, col) {
        for (const [r, c] of piece.getCells(row, col)) {
            if (r < 0 || c < 0 || r >= ROWS || c >= COLS) return false;
            if (blockedCells.has(`${r},${c}`)) return false;
            if (gridState[r][c] !== null) return false;
        }
        return true;
    }


    function trySnap(piece) {
        const gridRect = grid.getBoundingClientRect();
        const relX = piece.el.offsetLeft - gridRect.left;
        const relY = piece.el.offsetTop - gridRect.top;

        const col = Math.round(relX / CELL_SIZE);
        const row = Math.round(relY / CELL_SIZE);

        if (!canPlace(piece, row, col)) return;

        // Place new cells
        piece.getCells(row, col).forEach(([r, c]) => {
            gridState[r][c] = piece.id;
        });

        piece.el.style.left = `${gridRect.left + col * CELL_SIZE}px`;
        piece.el.style.top = `${gridRect.top + row * CELL_SIZE}px`;

        checkWin(this);
    }

    function checkWin() {
        let openCells = [];
        for (let i = 0; i < gridState.length; i++) {
            // The outer loop traverses the rows
            for (let j = 0; j < gridState[i].length; j++) {
                if (answerGrid[i][j] != "BLOCKED" && gridState[i][j] == null) {
                    openCells.push([i, j])
                }
            }
        }
        

        if (openCells.length == 3) {
            for (let i = 0; i < 3; i++) {
                if (!answers.includes(answerGrid[openCells[i][0]][openCells[i][1]])) return;
            }
            
            showWinWindow();

        }
    }

    function showWinWindow() {
        if (winShown) return; // prevent duplicates
        winShown = true;

        controller.abort(); 

        const elapsedMs = performance.now() - startTime;
        const seconds = Math.floor(elapsedMs / 1000);
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;

        const timeString =
            minutes > 0
                ? `${minutes}m ${remainingSeconds}s`
                : `${remainingSeconds}s`;

        // Overlay
        const overlay = document.createElement("div");
        overlay.style.position = "fixed";
        overlay.style.top = "0";
        overlay.style.left = "0";
        overlay.style.width = "100vw";
        overlay.style.height = "100vh";
        overlay.style.background = "rgba(0, 0, 0, 0.6)";
        overlay.style.display = "flex";
        overlay.style.alignItems = "center";
        overlay.style.justifyContent = "center";
        overlay.style.zIndex = "1000";

        // Window
        const windowEl = document.createElement("div");
        windowEl.style.background = "#1c1c1c";
        windowEl.style.color = "#ebebeb";
        windowEl.style.padding = "30px 40px";
        windowEl.style.minWidth = "300px";
        windowEl.style.position = "relative";
        windowEl.style.fontFamily = '"Barlow Condensed", sans-serif';
        windowEl.style.boxShadow = "0 0 40px rgba(235,235,235,0.4)";
        windowEl.style.border = "2px solid #ebebeb";

        // Close button
        const closeBtn = document.createElement("div");
        closeBtn.textContent = "âœ•";
        closeBtn.style.position = "absolute";
        closeBtn.style.top = "10px";
        closeBtn.style.right = "15px";
        closeBtn.style.cursor = "pointer";
        closeBtn.style.fontSize = "20px";

        closeBtn.onclick = () => overlay.remove();

        // Title
        const title = document.createElement("div");
        title.textContent = "You Win!";
        title.style.fontSize = "36px";
        title.style.marginBottom = "10px";
        title.style.textAlign = "center";
        title.style.textShadow = "0 0 10px rgba(235,235,235,0.6)";

        // Time text
        const timeText = document.createElement("div");
        timeText.textContent = `Completed in ${timeString}`;
        timeText.style.fontSize = "20px";
        timeText.style.textAlign = "center";
        timeText.style.opacity = "0.9";

        windowEl.appendChild(closeBtn);
        windowEl.appendChild(title);
        windowEl.appendChild(timeText);
        overlay.appendChild(windowEl);
        document.body.appendChild(overlay);
    }

    function clearPieceFromGrid(piece) {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (gridState[r][c] === piece.id) {
                    gridState[r][c] = null;
                }
            }
        }
    }


    let hoveredPiece = null;
    let hoveredCell = null;

    document.addEventListener("mousemove", e => {
        hoveredPiece = null;
        hoveredCell = null;

        const elements = document.elementsFromPoint(e.clientX, e.clientY);
        for (const el of elements) {
            const cell = el.closest(".piece-cell");
            if (cell) {
                const pieceEl = cell.closest(".piece");
                hoveredPiece = pieceEl.pieceRef;

                hoveredCell = {
                    r: parseInt(cell.dataset.r),
                    c: parseInt(cell.dataset.c)
                };
                break;
            }
        }
    });

    document.addEventListener("keydown", e => {
        if (e.key.toLowerCase() === "r" && hoveredPiece && hoveredCell) {
            rotatePiece(hoveredPiece, hoveredCell);
        }
        if (e.key.toLowerCase() === "f" && hoveredPiece) {
            flipPiece(hoveredPiece);
        }
    });

    function rotatePiece(piece, pivot) {
        if (!pivot) return;

        const { shape, el, id, flipped } = piece;

        const left = el.offsetLeft;
        const top = el.offsetTop;

        clearPieceFromGrid(piece);
        el.remove();

        const pr = pivot.r;
        const pc = pivot.c;

        const rotatedShape = shape.map(([r, c]) => {
            const r0 = r - pr;
            const c0 = c - pc;

            const r1 = c0;
            const c1 = -r0;

            return [r1 + pr, c1 + pc];
        });

        const newPiece = new Piece(id, rotatedShape, left, top, flipped);
        newPiece.color = newPiece.flipped ? "#ffcccc" : "#ebebeb";
        hoveredPiece = newPiece;
    }

    function flipPiece(piece) {
        const { shape, el, id, flipped } = piece;

        const left = el.offsetLeft;
        const top = el.offsetTop;

        clearPieceFromGrid(piece);
        el.remove();

        // Find mirror axis
        let minC = Infinity;
        let maxC = -Infinity;

        shape.forEach(([r, c]) => {
            minC = Math.min(minC, c);
            maxC = Math.max(maxC, c);
        });

        const mirrorC = minC + maxC;

        // Flip shape
        const flippedShape = shape.map(([r, c]) => [
            r,
            mirrorC - c
        ]);

        // Create new piece
        const newPiece = new Piece(id, flippedShape, left, top, flipped);

        // Toggle color state
        newPiece.flipped = !piece.flipped;
        newPiece.color = newPiece.flipped ? "#ffcccc" : "#ebebeb";

        // Apply color
        newPiece.el.querySelectorAll(".piece-cell").forEach(cell => {
            cell.style.background = newPiece.color;
        });

        hoveredPiece = newPiece;
    }


    const p0 = new Piece("A", SHAPES.LINE, 1100, 200, false);
    const p1 = new Piece("B", SHAPES.T, 50, 550, false);
    const p2 = new Piece("C", SHAPES.BATON, 300, 625, false);
    const p3 = new Piece("D", SHAPES.TALLZ, 850, 675, false);
    const p4 = new Piece("E", SHAPES.TALLL, 1300, 350, false);
    const p5 = new Piece("F", SHAPES.U, 600, 615, false);
    const p6 = new Piece("G", SHAPES.L, 60, 175, false);
    const p7 = new Piece("H", SHAPES.Z, 1080, 450, false);
    const p8 = new Piece("I", SHAPES.BLOCKUS, 200, 400, false);
    const p9 = new Piece("J", SHAPES.THUMB, 1150, 550, false);

  </script>

</body>
