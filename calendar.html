<head>
    <title>CoolSplish</title>

    <link rel="stylesheet" href="style.css">

    <!-- Barlow Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Aldrich&family=Barlow+Condensed:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            background: #1c1c1c;
            overflow-y: hidden;
            overflow-x: hidden;
        }

        /* Centers only the table */
        .table-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: calc(100vh - 200px);
        }

        .barlow-condensed-regular {
            font-family: "Barlow Condensed", sans-serif;
            font-weight: 400;
            font-style: normal;
        }

        table {
            border-collapse: collapse;
            outline: 20px solid #ebebeb; /* grows outward only */
            border-radius: 0px;
            text-shadow: 0 0 6px rgba(235, 235, 235, 0.75);
            outline-offset: 0;

            box-shadow: 0 0 55px rgba(235, 235, 235, 0.75);
        }

        td {
            width: 60px;
            height: 60px;
            user-select: none;
            box-sizing: border-box;
            color: #ebebeb;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            text-align: center;
            font-family: "Barlow Condensed", sans-serif;
            font-weight: 400;
            font-style: normal;
            font-size: 20px;
        }

        tr:last-child td:last-child {
            background: #ebebeb;
            /* outline: 2px solid #1c1c1c;
            outline-offset: -2px; */
        }

        .piece {
            position: absolute;
            cursor: grab;
        }

        .piece-cell {
            width: 60px;
            height: 60px;
            background: #ebebeb;
            position: absolute;
        }

    </style>
</head>
<body>

  <!-- Nav Bar -->
  <nav>
    <div></div>
    <div class="nav-name">Calendar Puzzle</div>
    <div class="nav-links">
      <a href="index.html">Home</a>
      <a href="about.html">About</a>
      <a href="projects.html">Projects</a>
      <a href="contact.html">Contact</a>
    </div>
</nav>
  <!-- Nav Bar -->
<div class="table-wrapper">
    <table id="grid">
        <tbody>
                <!-- 9 rows, 6 columns -->
            <tr>
                <td>JAN</td> <td>FEB</td> <td>MAR</td> <td>APR</td> <td>1</td> <td>2</td> <td>3</td> <td>MON</td> <td>TUE</td>
            </tr>
            <tr>
                <td>MAY</td> <td>4</td> <td>5</td> <td>6</td> <td>7</td> <td>8</td> <td>9</td> <td>WED</td><td></td>
            </tr>
            <tr>
                <td>JUN</td> <td>10</td> <td>11</td> <td>12</td> <td>13</td> <td>31</td> <td>15</td> <td>THU</td><td></td>
            </tr>
            <tr>
                <td>JUL</td> <td>16</td> <td>17</td> <td>18</td> <td>19</td> <td>20</td> <td>21</td> <td>FRI</td> <td>SAT</td>
            </tr>
            <tr>
                <td>AUG</td> <td>22</td> <td>23</td> <td>24</td> <td>25</td> <td>26</td> <td>27</td> <td></td> <td>SUN</td>
            </tr>
            <tr>
                <td>SEP</td> <td>OCT</td> <td>NOV</td> <td>DEC</td> <td>28</td> <td>29</td> <td>30</td> <td>14</td><td></td>
            </tr>
        </tbody>
    </table>
</div>

  <script>
    const CELL_SIZE = 60;
    const ROWS = 6;
    const COLS = 9;

    /*
    Grid state:
    null = empty
    string = piece id occupying that cell
    */
    const gridState = Array.from({ length: ROWS }, () =>
        Array(COLS).fill(null)
    );

    // Block bottom-right cell
    const blockedCells = new Set(["5,8"]); // row,col

    const SHAPES = {
        LINE: [
            [0, 0],
            [0, 1],
            [0, 2],
            [0, 3],
            [0, 4]
        ],

        T: [
            [0, 0],
            [0, 1],
            [0, 2],
            [1, 1],
            [2, 1]
        ],

        BATON: [
            [0, 0],
            [0, 1],
            [0, 2],
            [0, 3],
            [1, 1]
        ],

        TALLZ: [
            [0, 0],
            [0, 1],
            [0, 2],
            [-1, 2],
            [-1, 3]
        ],

        TALLL: [
            [0, 0],
            [0, 1],
            [1, 1],
            [2, 1],
            [3, 1]
        ],

        U: [
            [0, 0],
            [0, 2],
            [1, 0],
            [1, 1],
            [1, 2]
        ],

        L: [
            [0, 0],
            [0, 1],
            [0, 2],
            [1, 0],
            [2, 0]
        ],

        Z: [
            [0, 0],
            [-1, 0],
            [-1, 1],
            [-1, 2],
            [-2, 2]
        ],

        BLOCKUS: [
            [0, 0],
            [0, 1],
            [-1, 1],
            [-1, 2],
            [-2, 1]
        ],

        THUMB: [
            [0, 0],
            [0, 1],
            [0, 2],
            [-1, 1],
            [-1, 2]
        ]
    };


    class Piece {
        constructor(id, shape, startX, startY) {
            this.id = id;
            this.shape = shape;
            this.el = document.createElement("div");
            this.el.className = "piece";
            this.el.dataset.id = id;

            // Create visual cells
            shape.forEach(([r, c]) => {
                const cell = document.createElement("div");
                cell.className = "piece-cell";
                cell.style.left = `${c * CELL_SIZE}px`;
                cell.style.top = `${r * CELL_SIZE}px`;
                this.el.appendChild(cell);
            });

            this.el.style.left = `${startX}px`;
            this.el.style.top = `${startY}px`;

            document.body.appendChild(this.el);
            this.makeDraggable();
            this.addOutline();
        }

        getCells(row, col) {
            return this.shape.map(([r, c]) => [row + r, col + c]);
        }

        makeDraggable() {
            let offsetX, offsetY, dragging = false;

            this.el.addEventListener("mousedown", e => {
                dragging = true;
                offsetX = e.clientX - this.el.offsetLeft;
                offsetY = e.clientY - this.el.offsetTop;
                this.el.style.cursor = "grabbing";

                clearPieceFromGrid(this);
            });

            document.addEventListener("mousemove", e => {
                if (!dragging) return;
                this.el.style.left = `${e.clientX - offsetX}px`;
                this.el.style.top = `${e.clientY - offsetY}px`;
            });

            document.addEventListener("mouseup", () => {
                if (!dragging) return;
                dragging = false;
                this.el.style.cursor = "grab";
                trySnap(this);
            });
        }

        addOutline() {
            const STROKE = 1;
            // const INSET = STROKE / 2;
            const INSET = 0;

            // const edges = new Set();
            const edges = new Map();

            // For each cell, add its 4 edges
            this.shape.forEach(([r, c]) => {
                const x = c * CELL_SIZE;
                const y = r * CELL_SIZE;

                // const cellEdges = [
                //     `${x},${y} ${x + CELL_SIZE},${y}`,                 // top
                //     `${x + CELL_SIZE},${y} ${x + CELL_SIZE},${y + CELL_SIZE}`, // right
                //     `${x + CELL_SIZE},${y + CELL_SIZE} ${x},${y + CELL_SIZE}`, // bottom
                //     `${x},${y + CELL_SIZE} ${x},${y}`                  // left
                // ];

                const cellEdges = [
                    { x1: x, y1: y, x2: x + CELL_SIZE, y2: y,     nx: 0, ny: 1 },  // top (inward is +Y)
                    { x1: x + CELL_SIZE, y1: y, x2: x + CELL_SIZE, y2: y + CELL_SIZE, nx: -1, ny: 0 }, // right (inward is -X)
                    { x1: x + CELL_SIZE, y1: y + CELL_SIZE, x2: x, y2: y + CELL_SIZE, nx: 0, ny: -1 }, // bottom (inward is -Y)
                    { x1: x, y1: y + CELL_SIZE, x2: x, y2: y,     nx: 1, ny: 0 }   // left (inward is +X)
                ];

                const key = e => `${e.x1},${e.y1},${e.x2},${e.y2}`;
                const reverseKey = e => `${e.x2},${e.y2},${e.x1},${e.y1}`;
                cellEdges.forEach(edge => {
                    const rev = reverseKey(edge);
                    if (edges.has(rev)) {
                        edges.delete(rev);
                    } else {
                        edges.set(key(edge), edge);
                    }
                });

                // cellEdges.forEach(e => {
                //     // If opposite edge exists, remove it (internal edge)
                //     const reversed = e.split(" ").reverse().join(" ");
                //     if (edges.has(reversed)) {
                //         edges.delete(reversed);
                //     } else {
                //         edges.add(e);
                //     }
                // });
            });

            // Build SVG
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.style.position = "absolute";
            svg.style.left = "0";
            svg.style.top = "0";
            svg.style.overflow = "visible";
            svg.style.pointerEvents = "none";

            // edges.forEach(edge => {
            //     const [p1, p2] = edge.split(" ");
            //     const [x1, y1] = p1.split(",");
            //     const [x2, y2] = p2.split(",");

            //     const line = document.createElementNS(svg.namespaceURI, "line");
            //     line.setAttribute("x1", x1);
            //     line.setAttribute("y1", y1);
            //     line.setAttribute("x2", x2);
            //     line.setAttribute("y2", y2);
            //     line.setAttribute("stroke", "#1c1c1c");
            //     line.setAttribute("stroke-width", "2");
            //     line.setAttribute("stroke-linejoin", "round");

            //     svg.appendChild(line);
            edges.forEach(edge => {
                const { x1, y1, x2, y2, nx, ny } = edge;

                const line = document.createElementNS(svg.namespaceURI, "line");
                line.setAttribute("x1", x1 + nx * INSET);
                line.setAttribute("y1", y1 + ny * INSET);
                line.setAttribute("x2", x2 + nx * INSET);
                line.setAttribute("y2", y2 + ny * INSET);

                line.setAttribute("stroke", "#1c1c1c");
                line.setAttribute("stroke-width", STROKE);
                line.setAttribute("stroke-linejoin", "round");

                svg.appendChild(line);
            });

            this.el.appendChild(svg);
        }
    }


    function canPlace(piece, row, col) {
        for (const [r, c] of piece.getCells(row, col)) {
            if (r < 0 || c < 0 || r >= ROWS || c >= COLS) return false;
            if (blockedCells.has(`${r},${c}`)) return false;
            if (gridState[r][c] !== null) return false;
        }
        return true;
    }


    function trySnap(piece) {
        const gridRect = grid.getBoundingClientRect();
        const relX = piece.el.offsetLeft - gridRect.left;
        const relY = piece.el.offsetTop - gridRect.top;

        const col = Math.round(relX / CELL_SIZE);
        const row = Math.round(relY / CELL_SIZE);

        if (!canPlace(piece, row, col)) return;

        // Place new cells
        piece.getCells(row, col).forEach(([r, c]) => {
            gridState[r][c] = piece.id;
        });

        piece.el.style.left = `${gridRect.left + col * CELL_SIZE}px`;
        piece.el.style.top = `${gridRect.top + row * CELL_SIZE}px`;
    }

    function clearPieceFromGrid(piece) {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (gridState[r][c] === piece.id) {
                    gridState[r][c] = null;
                }
            }
        }
    }

    const p0 = new Piece("A", SHAPES.LINE, 1100, 200);
    const p1 = new Piece("B", SHAPES.T, 50, 550);
    const p2 = new Piece("C", SHAPES.BATON, 300, 625);
    const p3 = new Piece("D", SHAPES.TALLZ, 850, 675);
    const p4 = new Piece("E", SHAPES.TALLL, 1300, 350);
    const p5 = new Piece("F", SHAPES.U, 600, 615);
    const p6 = new Piece("G", SHAPES.L, 60, 175);
    const p7 = new Piece("H", SHAPES.Z, 1080, 450);
    const p8 = new Piece("I", SHAPES.BLOCKUS, 200, 400);
    const p9 = new Piece("J", SHAPES.THUMB, 1150, 550);

  </script>

</body>
